#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unpredictable_function_pointer_comparisons)]
/* automatically generated by rust-bindgen 0.69.5 */

#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ei_post_processing_output_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_ei_post_processing_output_t() {
    assert_eq!(
        ::std::mem::size_of::<ei_post_processing_output_t>(),
        1usize,
        concat!("Size of: ", stringify!(ei_post_processing_output_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_post_processing_output_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ei_post_processing_output_t))
    );
}
#[doc = " @brief Holds the output of inference, anomaly results, and timing information.\n\n `ei_impulse_result_t` holds the output of `run_classifier()`. If object detection is\n enabled, then the output results is a\n pointer to an array of bounding boxes of size `bounding_boxes_count`, as given by\n [ei_impulse_result_bounding_box_t](https://docs.edgeimpulse.com/reference/ei_impulse_result_bounding_box_t).\n Otherwise, results are stored as an array of classification scores, as given by\n [ei_impulse_result_classification_t](https://docs.edgeimpulse.com/reference/ei_impulse_result_classification_t).\n\n If anomaly detection is enabled (e.g. `EI_CLASSIFIER_HAS_ANOMALY == 1`), then the\n anomaly score will be stored as a floating point value in `anomaly`.\n\n Timing information is stored in an\n [ei_impulse_result_timing_t](https://docs.edgeimpulse.com/reference/ei_impulse_result_timing_t)\n struct.\n\n **Source**: [classifier/ei_classifier_types.h](https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/classifier/ei_classifier_types.h)\n\n **Example**: [standalone inferencing main.cpp](https://github.com/edgeimpulse/example-standalone-inferencing/blob/master/source/main.cpp)"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct ei_impulse_result_classification_t {
    #[doc = " Label of the detected object"]
    pub label: *const ::std::os::raw::c_char,
    #[doc = " Value of the detected object"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_ei_impulse_result_classification_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_impulse_result_classification_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_impulse_result_classification_t>(),
        16usize,
        concat!("Size of: ", stringify!(ei_impulse_result_classification_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_impulse_result_classification_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ei_impulse_result_classification_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_classification_t),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_classification_t),
            "::",
            stringify!(value)
        )
    );
}
impl Default for ei_impulse_result_classification_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Holds information for a single bounding box.\n\n If object detection is enabled (i.e. `EI_CLASSIFIER_OBJECT_DETECTION == 1`), then\n inference results will be one or more bounding boxes. The bounding boxes with the\n highest confidence scores (assuming those scores are equal to or greater than\n `EI_CLASSIFIER_OBJECT_DETECTION_THRESHOLD`), given by the `value` member, are\n returned from inference. The total number of bounding boxes returned will be at\n least `EI_CLASSIFIER_OBJECT_DETECTION_COUNT`. The exact number of bounding boxes\n is stored in `bounding_boxes_count` field of [ei_impulse_result_t]/C++ Inference\n SDK Library/structs/ei_impulse_result_t.md).\n\n A bounding box is a rectangle that ideally surrounds the identified object. The\n (`x`, `y`) coordinates in the struct identify the top-left corner of the box.\n `label` is the predicted class with the highest confidence score. `value` is the\n confidence score between [0.0..1.0] of the given `label`.\n\n **Source**: [classifier/ei_classifier_types.h](https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/classifier/ei_classifier_types.h)\n\n **Example**: [standalone inferencing main.cpp](https://github.com/edgeimpulse/example-standalone-inferencing/blob/master/source/main.cpp)"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct ei_impulse_result_bounding_box_t {
    #[doc = " Pointer to a character array describing the associated class of the given\n bounding box. Taken from one of the elements of\n `ei_classifier_inferencing_categories[]`."]
    pub label: *const ::std::os::raw::c_char,
    #[doc = " x coordinate of the top-left corner of the bounding box"]
    pub x: u32,
    #[doc = " y coordinate of the top-left corner of the bounding box"]
    pub y: u32,
    #[doc = " Width of the bounding box"]
    pub width: u32,
    #[doc = " Height of the bounding box"]
    pub height: u32,
    #[doc = " Confidence score of the label describing the bounding box"]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_ei_impulse_result_bounding_box_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_impulse_result_bounding_box_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_impulse_result_bounding_box_t>(),
        32usize,
        concat!("Size of: ", stringify!(ei_impulse_result_bounding_box_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_impulse_result_bounding_box_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ei_impulse_result_bounding_box_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_bounding_box_t),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_bounding_box_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_bounding_box_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_bounding_box_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_bounding_box_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_bounding_box_t),
            "::",
            stringify!(value)
        )
    );
}
impl Default for ei_impulse_result_bounding_box_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Holds timing information about the processing (DSP) and inference blocks.\n\n Records timing information during the execution of the preprocessing (DSP) and\n inference blocks. Can be used to determine if inference will meet timing requirements\n on your particular platform.\n\n **Source**: [classifier/ei_classifier_types.h](https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/classifier/ei_classifier_types.h)\n\n **Example**: [standalone inferencing main.cpp](https://github.com/edgeimpulse/example-standalone-inferencing/blob/master/source/main.cpp)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ei_impulse_result_timing_t {
    #[doc = " If using `run_impulse()` to perform sampling and inference, it is the amount of\n time (in milliseconds) it took to fetch raw samples. Not used for\n `run_classifier()`."]
    pub sampling: ::std::os::raw::c_int,
    #[doc = " Amount of time (in milliseconds) it took to run the preprocessing (DSP) block"]
    pub dsp: ::std::os::raw::c_int,
    #[doc = " Amount of time (in milliseconds) it took to run the inference block"]
    pub classification: ::std::os::raw::c_int,
    #[doc = " Amount of time (in milliseconds) it took to run anomaly detection. Valid only if\n `EI_CLASSIFIER_HAS_ANOMALY == 1`."]
    pub anomaly: ::std::os::raw::c_int,
    #[doc = " Amount of time (in microseconds) it took to run the post-processing block"]
    pub dsp_us: i64,
    #[doc = " Amount of time (in microseconds) it took to run the inference block"]
    pub classification_us: i64,
    #[doc = " Amount of time (in microseconds) it took to run anomaly detection. Valid only if\n `EI_CLASSIFIER_HAS_ANOMALY == 1`."]
    pub anomaly_us: i64,
}
#[test]
fn bindgen_test_layout_ei_impulse_result_timing_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_impulse_result_timing_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_impulse_result_timing_t>(),
        40usize,
        concat!("Size of: ", stringify!(ei_impulse_result_timing_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_impulse_result_timing_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ei_impulse_result_timing_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampling) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_timing_t),
            "::",
            stringify!(sampling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_timing_t),
            "::",
            stringify!(dsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classification) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_timing_t),
            "::",
            stringify!(classification)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).anomaly) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_timing_t),
            "::",
            stringify!(anomaly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp_us) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_timing_t),
            "::",
            stringify!(dsp_us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classification_us) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_timing_t),
            "::",
            stringify!(classification_us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).anomaly_us) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_timing_t),
            "::",
            stringify!(anomaly_us)
        )
    );
}
#[doc = " @brief Holds the output of inference, anomaly results, and timing information.\n\n `ei_impulse_result_t` holds the output of `run_classifier()`. If object detection is\n enabled (e.g. `EI_CLASSIFIER_OBJECT_DETECTION == 1`), then the output results is a\n pointer to an array of bounding boxes of size `bounding_boxes_count`, as given by\n [ei_impulse_result_bounding_box_t](https://docs.edgeimpulse.com/reference/ei_impulse_result_bounding_box_t).\n Otherwise, results are stored as an array of classification scores, as given by\n [ei_impulse_result_classification_t](https://docs.edgeimpulse.com/reference/ei_impulse_result_classification_t).\n\n If anomaly detection is enabled (e.g. `EI_CLASSIFIER_HAS_ANOMALY == 1`), then the\n anomaly score will be stored as a floating point value in `anomaly`.\n\n Timing information is stored in an\n [ei_impulse_result_timing_t](https://docs.edgeimpulse.com/reference/ei_impulse_result_timing_t)\n struct.\n\n **Source**: [classifier/ei_classifier_types.h](https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/classifier/ei_classifier_types.h)\n\n **Example**: [standalone inferencing main.cpp](https://github.com/edgeimpulse/example-standalone-inferencing/blob/master/source/main.cpp)"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct ei_impulse_result_t {
    #[doc = " Array of bounding boxes of the detected objects, if object detection is enabled."]
    pub bounding_boxes: *mut ei_impulse_result_bounding_box_t,
    #[doc = " Number of bounding boxes detected. If object detection is not enabled, this will\n be 0."]
    pub bounding_boxes_count: u32,
    pub classification: [ei_impulse_result_classification_t; 2usize],
    #[doc = " Anomaly score. If anomaly detection is not enabled, this will be 0. A higher\n anomaly score indicates greater likelihood of an anomalous sample (e.g. it is\n farther away from its cluster)."]
    pub anomaly: f32,
    #[doc = " Timing information for the processing (DSP) and inference blocks."]
    pub timing: ei_impulse_result_timing_t,
    #[doc = " Copy the output data to a buffer. If set to false, the output data will be\n returned as a pointer to the internal buffer. If set to true, the output data\n will be copied to the buffer provided in `ei_impulse_output_t`."]
    pub copy_output: bool,
    pub postprocessed_output: ei_post_processing_output_t,
}
#[test]
fn bindgen_test_layout_ei_impulse_result_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_impulse_result_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_impulse_result_t>(),
        104usize,
        concat!("Size of: ", stringify!(ei_impulse_result_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_impulse_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ei_impulse_result_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bounding_boxes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_t),
            "::",
            stringify!(bounding_boxes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bounding_boxes_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_t),
            "::",
            stringify!(bounding_boxes_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).classification) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_t),
            "::",
            stringify!(classification)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).anomaly) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_t),
            "::",
            stringify!(anomaly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_t),
            "::",
            stringify!(timing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy_output) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_t),
            "::",
            stringify!(copy_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).postprocessed_output) as usize - ptr as usize },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_result_t),
            "::",
            stringify!(postprocessed_output)
        )
    );
}
impl Default for ei_impulse_result_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[doc = " @defgroup ei_returntypes Return codes\n\n Return codes for Edge Impulse functions.\n\n **Source**: [dsp/returntypes.h](https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/dsp/returntypes.h)\n\n @addtogroup ei_returntypes\n @{"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum EI_IMPULSE_ERROR {
    #[doc = "< Success"]
    EI_IMPULSE_OK = 0,
    #[doc = "< The shape of data does not match the shape of input layer."]
    EI_IMPULSE_ERROR_SHAPES_DONT_MATCH = -1,
    #[doc = "< Impulse execution is cancelled by user."]
    EI_IMPULSE_CANCELED = -2,
    #[doc = "< Error in TesnorFlow Lite inference engine"]
    EI_IMPULSE_TFLITE_ERROR = -3,
    #[doc = "< Error in processing portion of impulse"]
    EI_IMPULSE_DSP_ERROR = -5,
    #[doc = "< Failed to allocate memory in TensorFlow Lite arena, often caused by a lack of available heap memory."]
    EI_IMPULSE_TFLITE_ARENA_ALLOC_FAILED = -6,
    #[doc = "< Error in CubeAI inference engine (STM32)"]
    EI_IMPULSE_CUBEAI_ERROR = -7,
    #[doc = "< Memory allocation failed. Could be caused by a fragmented heap. Try to increase heap size."]
    EI_IMPULSE_ALLOC_FAILED = -8,
    #[doc = "< This function is only supported for impulses with an image input."]
    EI_IMPULSE_ONLY_SUPPORTED_FOR_IMAGES = -9,
    #[doc = "< The chosen inference engine (e.g. in Studio) is incapable of running this impulse."]
    EI_IMPULSE_UNSUPPORTED_INFERENCING_ENGINE = -10,
    #[doc = "< Out of memory. Could be caused by a fragmented heap. Try to increase heap size."]
    EI_IMPULSE_OUT_OF_MEMORY = -11,
    #[doc = "< Input tensor was null"]
    EI_IMPULSE_INPUT_TENSOR_WAS_NULL = -13,
    #[doc = "< Output tensor was null"]
    EI_IMPULSE_OUTPUT_TENSOR_WAS_NULL = -14,
    #[doc = "< Score tensor is null (for SSD Object Detection models)."]
    EI_IMPULSE_SCORE_TENSOR_WAS_NULL = -15,
    #[doc = "< Label tensor is null (for SSD Object Detection models)."]
    EI_IMPULSE_LABEL_TENSOR_WAS_NULL = -16,
    #[doc = "< TensorRT (NVIDIA) initialization failed."]
    EI_IMPULSE_TENSORRT_INIT_FAILED = -17,
    #[doc = "< DRP-AI (Renesas) initialization failed."]
    EI_IMPULSE_DRPAI_INIT_FAILED = -18,
    #[doc = "< DRP-AI (Renesas) runtime failed."]
    EI_IMPULSE_DRPAI_RUNTIME_FAILED = -19,
    #[doc = "< The model is deprecated and cannot be used. You should re-export the impulse from Studio."]
    EI_IMPULSE_DEPRECATED_MODEL = -20,
    #[doc = "< The last layer is not available in the model."]
    EI_IMPULSE_LAST_LAYER_NOT_AVAILABLE = -21,
    #[doc = "< Error during inference."]
    EI_IMPULSE_INFERENCE_ERROR = -22,
    #[doc = "< Error in Akida inference engine (BrainChip)"]
    EI_IMPULSE_AKIDA_ERROR = -23,
    #[doc = "<The shape of data does not match the shape of input layer."]
    EI_IMPULSE_INVALID_SIZE = -24,
    #[doc = "< Error in ONNX inference engine"]
    EI_IMPULSE_ONNX_ERROR = -25,
    #[doc = "< Error in Memryx inference engine"]
    EI_IMPULSE_MEMRYX_ERROR = -26,
    #[doc = "< Device initialization (usually NPU accelerator) failed"]
    EI_IMPULSE_DEVICE_INIT_ERROR = -27,
    #[doc = "< The last layer is not supported by inferencing engine."]
    EI_IMPULSE_LAST_LAYER_NOT_SUPPORTED = -28,
    #[doc = "< Error in post-processing portion of impulse"]
    EI_IMPULSE_POSTPROCESSING_ERROR = -29,
}
#[doc = " A matrix structure that allocates a matrix on the **heap**.\n Freeing happens by calling `delete` on the object or letting the object go out of scope."]
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ei_ei_matrix {
    pub buffer: *mut f32,
    pub rows: u32,
    pub cols: u32,
    pub buffer_managed_by_me: bool,
}
#[test]
fn bindgen_test_layout_ei_ei_matrix() {
    const UNINIT: ::std::mem::MaybeUninit<ei_ei_matrix> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_ei_matrix>(),
        24usize,
        concat!("Size of: ", stringify!(ei_ei_matrix))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_ei_matrix>(),
        8usize,
        concat!("Alignment of ", stringify!(ei_ei_matrix))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_ei_matrix),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_ei_matrix),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cols) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_ei_matrix),
            "::",
            stringify!(cols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_managed_by_me) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_ei_matrix),
            "::",
            stringify!(buffer_managed_by_me)
        )
    );
}
impl Default for ei_ei_matrix {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A matrix structure that allocates a matrix on the **heap**.\n Freeing happens by calling `delete` on the object or letting the object go out of scope."]
pub type ei_matrix_t = ei_ei_matrix;
#[doc = " @brief Holds the callback pointer for retrieving raw data and the length\n  of data to be retrieved.\n\n  Holds the callback function, `get_data(size_t offset, size_t length, float\n  *out_ptr)`. This callback should be implemented by the user and fills the memory\n  location given by `*out_ptr` with raw features. Features must be flattened to a\n  1-dimensional vector, as described in\n  [this guide](https://docs.edgeimpulse.com/docs/deploy-your-model-as-a-c-library#signal-structure).\n\n  `get_data()` may be called multiple times during preprocessing or inference (e.g.\n  during execution of\n  [run_classifier()](https://docs.edgeimpulse.com/reference/run_classifier) or\n  [run_classifier_continuous()](https://docs.edgeimpulse.com/reference/run_classifier_continuous)).\n  The `offset` argument will update to point to new data, and `length` data must\n  be copied into the location specified by `out_ptr`. This scheme allows raw features\n  to be stored in RAM or flash memory and paged in as necessary.\n\n  Note that `get_data()` (even after multiple calls during a single execution of\n  `run_classifier()` or `run_classifier_continuous()`) will never request more than a\n  total number of features as given by `total_length`.\n\n **Source**: [dsp/numpy_types.h](https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/dsp/numpy_types.h)\n\n **Example**: [standalone inferencing main.cpp](https://github.com/edgeimpulse/example-standalone-inferencing/blob/master/source/main.cpp)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ei_ei_signal_t {
    pub get_data: [u64; 4usize],
    #[doc = " Total number of samples the user will provide (via get_data).  This value should match either the total number of raw features required for a full window (ie, the window size in Studio, but in samples), OR, if using run_classifier_continuous(), the number of samples in a single slice)\n  for a new slice (`run_classifier_continuous()`) in order to perform\n  preprocessing and inference."]
    pub total_length: usize,
}
#[test]
fn bindgen_test_layout_ei_ei_signal_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_ei_signal_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_ei_signal_t>(),
        40usize,
        concat!("Size of: ", stringify!(ei_ei_signal_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_ei_signal_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ei_ei_signal_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_ei_signal_t),
            "::",
            stringify!(get_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_ei_signal_t),
            "::",
            stringify!(total_length)
        )
    );
}
#[doc = " @brief Holds the callback pointer for retrieving raw data and the length\n  of data to be retrieved.\n\n  Holds the callback function, `get_data(size_t offset, size_t length, float\n  *out_ptr)`. This callback should be implemented by the user and fills the memory\n  location given by `*out_ptr` with raw features. Features must be flattened to a\n  1-dimensional vector, as described in\n  [this guide](https://docs.edgeimpulse.com/docs/deploy-your-model-as-a-c-library#signal-structure).\n\n  `get_data()` may be called multiple times during preprocessing or inference (e.g.\n  during execution of\n  [run_classifier()](https://docs.edgeimpulse.com/reference/run_classifier) or\n  [run_classifier_continuous()](https://docs.edgeimpulse.com/reference/run_classifier_continuous)).\n  The `offset` argument will update to point to new data, and `length` data must\n  be copied into the location specified by `out_ptr`. This scheme allows raw features\n  to be stored in RAM or flash memory and paged in as necessary.\n\n  Note that `get_data()` (even after multiple calls during a single execution of\n  `run_classifier()` or `run_classifier_continuous()`) will never request more than a\n  total number of features as given by `total_length`.\n\n **Source**: [dsp/numpy_types.h](https://github.com/edgeimpulse/inferencing-sdk-cpp/blob/master/dsp/numpy_types.h)\n\n **Example**: [standalone inferencing main.cpp](https://github.com/edgeimpulse/example-standalone-inferencing/blob/master/source/main.cpp)"]
pub type ei_signal_t = ei_ei_signal_t;
#[repr(C)]
pub struct DspHandle__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct DspHandle {
    pub vtable_: *const DspHandle__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_DspHandle() {
    assert_eq!(
        ::std::mem::size_of::<DspHandle>(),
        8usize,
        concat!("Size of: ", stringify!(DspHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<DspHandle>(),
        8usize,
        concat!("Alignment of ", stringify!(DspHandle))
    );
}
impl Default for DspHandle {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ei_feature_t {
    pub matrix: *mut ei_matrix_t,
    pub blockId: u32,
}
#[test]
fn bindgen_test_layout_ei_feature_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_feature_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_feature_t>(),
        16usize,
        concat!("Size of: ", stringify!(ei_feature_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_feature_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ei_feature_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_feature_t),
            "::",
            stringify!(matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_feature_t),
            "::",
            stringify!(blockId)
        )
    );
}
impl Default for ei_feature_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type extract_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        signal: *mut ei_signal_t,
        output_matrix: *mut ei_matrix_t,
        config: *mut ::std::os::raw::c_void,
        frequency: f32,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ei_model_dsp_t {
    pub blockId: u32,
    pub n_output_features: usize,
    pub extract_fn: extract_fn_t,
    pub config: *mut ::std::os::raw::c_void,
    pub axes: *mut u8,
    pub axes_size: u32,
    pub version: ::std::os::raw::c_int,
    pub factory: ::std::option::Option<
        unsafe extern "C" fn(
            config: *mut ::std::os::raw::c_void,
            sampling_freq: f32,
        ) -> *mut DspHandle,
    >,
}
#[test]
fn bindgen_test_layout_ei_model_dsp_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_model_dsp_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_model_dsp_t>(),
        56usize,
        concat!("Size of: ", stringify!(ei_model_dsp_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_model_dsp_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ei_model_dsp_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_model_dsp_t),
            "::",
            stringify!(blockId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_output_features) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_model_dsp_t),
            "::",
            stringify!(n_output_features)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extract_fn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_model_dsp_t),
            "::",
            stringify!(extract_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_model_dsp_t),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_model_dsp_t),
            "::",
            stringify!(axes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axes_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_model_dsp_t),
            "::",
            stringify!(axes_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_model_dsp_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).factory) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_model_dsp_t),
            "::",
            stringify!(factory)
        )
    );
}
impl Default for ei_model_dsp_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ei_learning_block_t {
    pub blockId: u32,
    pub keep_output: bool,
    pub infer_fn: ::std::option::Option<
        unsafe extern "C" fn(
            impulse: *const ei_impulse,
            fmatrix: *mut ei_feature_t,
            learn_block_index: u32,
            input_block_ids: *mut u32,
            input_block_ids_size: u32,
            result: *mut ei_impulse_result_t,
            config: *mut ::std::os::raw::c_void,
            debug: bool,
        ) -> EI_IMPULSE_ERROR,
    >,
    pub config: *mut ::std::os::raw::c_void,
    pub image_scaling: ::std::os::raw::c_int,
    pub input_block_ids: *const u32,
    pub input_block_ids_size: u8,
    pub output_features_count: u32,
}
#[test]
fn bindgen_test_layout_ei_learning_block_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_learning_block_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_learning_block_t>(),
        48usize,
        concat!("Size of: ", stringify!(ei_learning_block_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_learning_block_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ei_learning_block_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_learning_block_t),
            "::",
            stringify!(blockId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_output) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_learning_block_t),
            "::",
            stringify!(keep_output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).infer_fn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_learning_block_t),
            "::",
            stringify!(infer_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_learning_block_t),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_scaling) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_learning_block_t),
            "::",
            stringify!(image_scaling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_block_ids) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_learning_block_t),
            "::",
            stringify!(input_block_ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_block_ids_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_learning_block_t),
            "::",
            stringify!(input_block_ids_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_features_count) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_learning_block_t),
            "::",
            stringify!(output_features_count)
        )
    );
}
impl Default for ei_learning_block_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ei_postprocessing_block_t {
    pub block_id: u32,
    pub init_fn: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ei_impulse_handle_t,
            state: *mut *mut ::std::os::raw::c_void,
            config: *mut ::std::os::raw::c_void,
        ) -> EI_IMPULSE_ERROR,
    >,
    pub deinit_fn: ::std::option::Option<
        unsafe extern "C" fn(
            state: *mut ::std::os::raw::c_void,
            config: *mut ::std::os::raw::c_void,
        ) -> EI_IMPULSE_ERROR,
    >,
    pub postprocess_fn: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ei_impulse_handle_t,
            result: *mut ei_impulse_result_t,
            config: *mut ::std::os::raw::c_void,
            state: *mut ::std::os::raw::c_void,
        ) -> EI_IMPULSE_ERROR,
    >,
    pub display_fn: ::std::option::Option<
        unsafe extern "C" fn(
            result: *mut ei_impulse_result_t,
            config: *mut ::std::os::raw::c_void,
        ) -> EI_IMPULSE_ERROR,
    >,
    pub config: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ei_postprocessing_block_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_postprocessing_block_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_postprocessing_block_t>(),
        48usize,
        concat!("Size of: ", stringify!(ei_postprocessing_block_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_postprocessing_block_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ei_postprocessing_block_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_postprocessing_block_t),
            "::",
            stringify!(block_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_fn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_postprocessing_block_t),
            "::",
            stringify!(init_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deinit_fn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_postprocessing_block_t),
            "::",
            stringify!(deinit_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).postprocess_fn) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_postprocessing_block_t),
            "::",
            stringify!(postprocess_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_fn) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_postprocessing_block_t),
            "::",
            stringify!(display_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_postprocessing_block_t),
            "::",
            stringify!(config)
        )
    );
}
impl Default for ei_postprocessing_block_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct ei_object_detection_nms_config_t {
    pub confidence_threshold: f32,
    pub iou_threshold: f32,
}
#[test]
fn bindgen_test_layout_ei_object_detection_nms_config_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_object_detection_nms_config_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_object_detection_nms_config_t>(),
        8usize,
        concat!("Size of: ", stringify!(ei_object_detection_nms_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_object_detection_nms_config_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ei_object_detection_nms_config_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).confidence_threshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_object_detection_nms_config_t),
            "::",
            stringify!(confidence_threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iou_threshold) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_object_detection_nms_config_t),
            "::",
            stringify!(iou_threshold)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct ei_impulse {
    pub project_id: u32,
    pub project_owner: *const ::std::os::raw::c_char,
    pub project_name: *const ::std::os::raw::c_char,
    pub impulse_id: u16,
    pub impulse_name: *const ::std::os::raw::c_char,
    pub deploy_version: u16,
    pub nn_input_frame_size: u32,
    pub raw_sample_count: u32,
    pub raw_samples_per_frame: u32,
    pub dsp_input_frame_size: u32,
    pub input_width: u32,
    pub input_height: u32,
    pub input_frames: u32,
    pub interval_ms: f32,
    pub frequency: f32,
    pub dsp_blocks_size: u8,
    pub dsp_blocks: *mut ei_model_dsp_t,
    pub object_detection_count: u16,
    pub fomo_output_size: u32,
    pub visual_ad_grid_size_x: u16,
    pub visual_ad_grid_size_y: u16,
    pub tflite_output_features_count: u32,
    pub learning_blocks_size: u8,
    pub learning_blocks: *const ei_learning_block_t,
    pub postprocessing_blocks_size: usize,
    pub postprocessing_blocks: *const ei_postprocessing_block_t,
    pub inferencing_engine: u8,
    pub sensor: u8,
    pub fusion_string: *const ::std::os::raw::c_char,
    pub slice_size: u32,
    pub slices_per_model_window: u8,
    pub has_anomaly: u8,
    pub label_count: u16,
    pub categories: *mut *const ::std::os::raw::c_char,
    pub object_detection_nms: ei_object_detection_nms_config_t,
}
#[test]
fn bindgen_test_layout_ei_impulse() {
    const UNINIT: ::std::mem::MaybeUninit<ei_impulse> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_impulse>(),
        184usize,
        concat!("Size of: ", stringify!(ei_impulse))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_impulse>(),
        8usize,
        concat!("Alignment of ", stringify!(ei_impulse))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).project_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(project_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).project_owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(project_owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).project_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(project_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impulse_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(impulse_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impulse_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(impulse_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deploy_version) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(deploy_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nn_input_frame_size) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(nn_input_frame_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_sample_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(raw_sample_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_samples_per_frame) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(raw_samples_per_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp_input_frame_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(dsp_input_frame_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_width) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(input_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_height) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(input_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_frames) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(input_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval_ms) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(interval_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp_blocks_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(dsp_blocks_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp_blocks) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(dsp_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_detection_count) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(object_detection_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fomo_output_size) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(fomo_output_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual_ad_grid_size_x) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(visual_ad_grid_size_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visual_ad_grid_size_y) as usize - ptr as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(visual_ad_grid_size_y)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).tflite_output_features_count) as usize - ptr as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(tflite_output_features_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).learning_blocks_size) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(learning_blocks_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).learning_blocks) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(learning_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).postprocessing_blocks_size) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(postprocessing_blocks_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).postprocessing_blocks) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(postprocessing_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inferencing_engine) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(inferencing_engine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor) as usize - ptr as usize },
        145usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(sensor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fusion_string) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(fusion_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_size) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(slice_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slices_per_model_window) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(slices_per_model_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_anomaly) as usize - ptr as usize },
        165usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(has_anomaly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label_count) as usize - ptr as usize },
        166usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(label_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).categories) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(categories)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_detection_nms) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse),
            "::",
            stringify!(object_detection_nms)
        )
    );
}
impl Default for ei_impulse {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ei_impulse_t = ei_impulse;
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ei_impulse_state_t {
    pub impulse: *const ei_impulse_t,
    pub dsp_handles: *mut ei_impulse_state_t__dsp_handle_ptr_t,
    pub is_temp_handle: bool,
}
pub type ei_impulse_state_t__dsp_handle_ptr_t = *mut DspHandle;
#[test]
fn bindgen_test_layout_ei_impulse_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_impulse_state_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_impulse_state_t>(),
        24usize,
        concat!("Size of: ", stringify!(ei_impulse_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_impulse_state_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ei_impulse_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impulse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_state_t),
            "::",
            stringify!(impulse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp_handles) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_state_t),
            "::",
            stringify!(dsp_handles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_temp_handle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_state_t),
            "::",
            stringify!(is_temp_handle)
        )
    );
}
impl Default for ei_impulse_state_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ei_impulse_handle_t {
    pub state: ei_impulse_state_t,
    pub impulse: *const ei_impulse_t,
    pub post_processing_state: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ei_impulse_handle_t() {
    const UNINIT: ::std::mem::MaybeUninit<ei_impulse_handle_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ei_impulse_handle_t>(),
        40usize,
        concat!("Size of: ", stringify!(ei_impulse_handle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ei_impulse_handle_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ei_impulse_handle_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_handle_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impulse) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_handle_t),
            "::",
            stringify!(impulse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).post_processing_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ei_impulse_handle_t),
            "::",
            stringify!(post_processing_state)
        )
    );
}
impl Default for ei_impulse_handle_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn ei_ffi_run_classifier_init();
}
unsafe extern "C" {
    pub fn ei_ffi_run_classifier_deinit();
}
unsafe extern "C" {
    pub fn ei_ffi_init_impulse(handle: *mut ei_impulse_handle_t) -> EI_IMPULSE_ERROR;
}
unsafe extern "C" {
    pub fn ei_ffi_run_classifier(
        signal: *mut ei_signal_t,
        result: *mut ei_impulse_result_t,
        debug: ::std::os::raw::c_int,
    ) -> EI_IMPULSE_ERROR;
}
unsafe extern "C" {
    pub fn ei_ffi_run_classifier_continuous(
        signal: *mut ei_signal_t,
        result: *mut ei_impulse_result_t,
        debug: ::std::os::raw::c_int,
        enable_maf_unused: ::std::os::raw::c_int,
    ) -> EI_IMPULSE_ERROR;
}
unsafe extern "C" {
    pub fn ei_ffi_run_inference(
        handle: *mut ei_impulse_handle_t,
        fmatrix: *mut ei_feature_t,
        result: *mut ei_impulse_result_t,
        debug: ::std::os::raw::c_int,
    ) -> EI_IMPULSE_ERROR;
}
unsafe extern "C" {
    pub fn ei_ffi_signal_from_buffer(
        data: *const f32,
        data_size: usize,
        signal: *mut ei_signal_t,
    ) -> EI_IMPULSE_ERROR;
}
